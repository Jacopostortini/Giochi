{"remainingRequest":"C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\node_modules\\vue-loader-v16\\dist\\index.js??ref--0-1!C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\src\\components\\gamePhaseComponents\\MapManager.vue?vue&type=style&index=0&id=0287285e&lang=scss&scoped=true","dependencies":[{"path":"C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\src\\components\\gamePhaseComponents\\MapManager.vue","mtime":1615793205235},{"path":"C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\node_modules\\css-loader\\dist\\cjs.js","mtime":1615312363675},{"path":"C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\node_modules\\vue-loader-v16\\dist\\stylePostLoader.js","mtime":1615312384354},{"path":"C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\node_modules\\postcss-loader\\src\\index.js","mtime":1615312374633},{"path":"C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\node_modules\\sass-loader\\dist\\cjs.js","mtime":1615312380962},{"path":"C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1615312359986},{"path":"C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\node_modules\\vue-loader-v16\\dist\\index.js","mtime":1615312384341}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:DQoNCi5tYXAtbWFuYWdlcl9fbWFpbi1wYW5lbHsNCiAgb3ZlcmZsb3c6IGhpZGRlbjsNCiAgd2lkdGg6IDEwMCU7DQogIGhlaWdodDogMTAwJTsNCiAgQG1lZGlhIChtYXgtd2lkdGg6IDUwMHB4KSB7DQogICAgd2lkdGg6IDEwMCU7DQogICAgaGVpZ2h0OiAzMDBweDsNCiAgICBwb3NpdGlvbjogc3RpY2t5Ow0KICAgIHRvcDogMDsNCiAgICB6LWluZGV4OiAyOw0KICB9DQp9DQo="},{"version":3,"sources":["C:\\Users\\matte\\Desktop\\papero\\unseen.papero.tk\\src\\components\\gamePhaseComponents\\MapManager.vue"],"names":[],"mappings":";;AAuZA,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EACtB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;EAChB,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACZ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;IACxB,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;IACX,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IACb,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAChB,CAAC,CAAC,CAAC,EAAE,CAAC;IACN,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;EACZ;AACF","file":"C:/Users/matte/Desktop/papero/unseen.papero.tk/src/components/gamePhaseComponents/MapManager.vue","sourceRoot":"","sourcesContent":["<template>\r\n  <div class=\"map-manager__main-panel\" id=\"map-manager__main-panel\"></div>\r\n</template>\r\n\r\n<script>\r\nimport *  as PIXI from \"pixi.js-legacy\";\r\nimport mitt from \"mitt\";\r\nimport {\r\n  keyPressed,\r\n  tilesetsDimension,\r\n  mapDimension,\r\n  tileSize,\r\n  zoomAndPanParams\r\n} from \"../../constants/mapConstants\";\r\nimport stations from \"../../constants/stations\";\r\nimport {onMounted, ref} from \"vue\";\r\nimport pathsTilesetImage from \"../../assets/tilesets/pathsTileset.png\";\r\nimport stationsTilesetImage from \"../../assets/tilesets/stationsTileset.png\";\r\nimport streetsTilesetImage from \"../../assets/tilesets/streetsTileset.png\";\r\nimport buildingsTilesetImage from \"../../assets/tilesets/buildingsTileset.png\";\r\nimport backgroundTilesetImage from \"../../assets/tilesets/backgroundTileset.png\";\r\nimport pawnsTilesetImage from \"../../assets/tilesets/pawnsTileset.png\";\r\nimport paths from \"../../constants/paths\";\r\nimport streets from \"../../constants/streets\";\r\nimport buildings from \"../../constants/buildings\";\r\nimport background from \"../../constants/background\";\r\n\r\nimport renderer from \"../../modules/renderer\";\r\n\r\nwindow.mitt = window.mitt || new mitt();\r\nexport default {\r\n  name: \"MapManager\",\r\n  props: {\r\n    players: Array,\r\n    currentPlayer: Object,\r\n    autoZoom: Boolean\r\n  },\r\n  setup(props, ctx) {\r\n    const app = new PIXI.Application({\r\n      width: tileSize * mapDimension.width,\r\n      height: tileSize * mapDimension.height,\r\n      backgroundColor: 0xf7f7f7,\r\n      antialias: false\r\n    });\r\n\r\n    PIXI.settings.ROUND_PIXELS = true;\r\n\r\n    app.loader\r\n        .add(\"pathsTileset\", pathsTilesetImage)\r\n        .add(\"stationsTileset\", stationsTilesetImage)\r\n        .add(\"streetsTileset\", streetsTilesetImage)\r\n        .add(\"buildingsTileset\", buildingsTilesetImage)\r\n        .add(\"backgroundTileset\", backgroundTilesetImage)\r\n        .add(\"pawnsTileset\", pawnsTilesetImage)\r\n        .load((loader, resources) => {\r\n\r\n          //crop tilesets to get tiles textures\r\n          let textures = {\r\n            paths: [],\r\n            stations: [],\r\n            streets: [],\r\n            buildings: [],\r\n            backgrounds: [],\r\n            pawns: []\r\n          }\r\n\r\n          for (let i = 0; i < tilesetsDimension.paths.width * tilesetsDimension.paths.height; i++) {\r\n            let x = i % tilesetsDimension.paths.width;\r\n            let y = Math.floor(i / tilesetsDimension.paths.width);\r\n            textures.paths[i] = new PIXI.Texture(\r\n                resources.pathsTileset.texture,\r\n                new PIXI.Rectangle(x * tileSize, y * tileSize, tileSize, tileSize)\r\n            );\r\n          }\r\n\r\n          for (let i = 0; i < tilesetsDimension.stations.width * tilesetsDimension.stations.height; i++) {\r\n            let x = i % tilesetsDimension.stations.width;\r\n            let y = Math.floor(i / tilesetsDimension.stations.width);\r\n            textures.stations[i] = new PIXI.Texture(\r\n                resources.stationsTileset.texture,\r\n                new PIXI.Rectangle(x * tileSize, y * tileSize, tileSize, tileSize)\r\n            );\r\n          }\r\n\r\n          for (let i = 0; i < tilesetsDimension.streets.width * tilesetsDimension.streets.height; i++) {\r\n            let x = i % tilesetsDimension.streets.width;\r\n            let y = Math.floor(i / tilesetsDimension.streets.width);\r\n            textures.streets[i] = new PIXI.Texture(\r\n                resources.streetsTileset.texture,\r\n                new PIXI.Rectangle(x * tileSize, y * tileSize, tileSize, tileSize)\r\n            );\r\n          }\r\n\r\n          for (let i = 0; i < tilesetsDimension.buildings.width * tilesetsDimension.buildings.height; i++) {\r\n            let x = i % tilesetsDimension.buildings.width;\r\n            let y = Math.floor(i / tilesetsDimension.buildings.width);\r\n            textures.buildings[i] = new PIXI.Texture(\r\n                resources.buildingsTileset.texture,\r\n                new PIXI.Rectangle(x * tileSize, y * tileSize, tileSize, tileSize)\r\n            );\r\n          }\r\n\r\n          for (let i = 0; i < tilesetsDimension.background.width * tilesetsDimension.background.height; i++) {\r\n            let x = i % tilesetsDimension.background.width;\r\n            let y = Math.floor(i / tilesetsDimension.background.width);\r\n            textures.backgrounds[i] = new PIXI.Texture(\r\n                resources.backgroundTileset.texture,\r\n                new PIXI.Rectangle(x * tileSize, y * tileSize, tileSize, tileSize)\r\n            );\r\n          }\r\n\r\n          for (let i = 0; i < tilesetsDimension.pawns.width * tilesetsDimension.pawns.height; i++) {\r\n            let x = i % tilesetsDimension.pawns.width;\r\n            let y = Math.floor(i / tilesetsDimension.pawns.width);\r\n            textures.pawns[i] = new PIXI.Texture(\r\n                resources.pawnsTileset.texture,\r\n                new PIXI.Rectangle(x * tileSize, y * tileSize * 2, tileSize, tileSize * 2)\r\n            );\r\n          }\r\n\r\n          let pathsContainer = new PIXI.Container();\r\n          let streetsContainer = new PIXI.Container();\r\n          let buildingsContainer = new PIXI.Container();\r\n          let backgroundContainer = new PIXI.Container();\r\n\r\n          for (let row = 0; row < mapDimension.height; row++){\r\n            for (let col = 0; col < mapDimension.width; col++){\r\n              let pathCode = paths[row][col];\r\n              if(pathCode>=0) {\r\n                let pathTexture = textures.paths[pathCode];\r\n                let pathSprite = new PIXI.Sprite(pathTexture);\r\n                pathSprite.x = tileSize * col;\r\n                pathSprite.y = tileSize * row;\r\n                pathsContainer.addChild(pathSprite);\r\n              }\r\n\r\n              let streetCode = streets[row][col];\r\n              if(streetCode>=0){\r\n                let streetsTexture = textures.streets[streetCode];\r\n                let streetsSprite = new PIXI.Sprite(streetsTexture);\r\n                streetsSprite.x = tileSize * col;\r\n                streetsSprite.y = tileSize * row;\r\n                streetsContainer.addChild(streetsSprite);\r\n              }\r\n\r\n              let buildingCode = buildings[row][col];\r\n              if(buildingCode>=0) {\r\n                let buildingsTexture = textures.buildings[buildingCode];\r\n                let buildingsSprite = new PIXI.Sprite(buildingsTexture);\r\n                buildingsSprite.x = tileSize * col;\r\n                buildingsSprite.y = tileSize * row;\r\n                buildingsContainer.addChild(buildingsSprite);\r\n              }\r\n\r\n              let backgroundCode = background[row][col];\r\n              if(backgroundCode>=0) {\r\n                let backgroundTexture = textures.backgrounds[backgroundCode];\r\n                let backgroundSprite = new PIXI.Sprite(backgroundTexture);\r\n                backgroundSprite.x = tileSize * col;\r\n                backgroundSprite.y = tileSize * row;\r\n                backgroundContainer.addChild(backgroundSprite);\r\n              }\r\n            }\r\n          }\r\n\r\n          let stationsContainer = new PIXI.Container();\r\n          for(let i = 0; i < stations.length; i++){\r\n            let sprite = new PIXI.Sprite(textures.stations[stations[i].type]);\r\n            sprite.x = tileSize * stations[i].point[0];\r\n            sprite.y = tileSize * stations[i].point[1];\r\n            let color = (stations[i].type === 2) ? \"white\" : \"black\";\r\n            let label = new PIXI.Text(stations[i].number, {fontFamily: \"sans-serif\", fontWeight: \"bold\", fill: color});\r\n            label.anchor.x = label.anchor.y = 0.5;\r\n            label.x = sprite.width / 2;\r\n            label.y = sprite.height / 2;\r\n            sprite.addChild(label);\r\n            sprite.interactive = true;\r\n            sprite.buttonMode = true;\r\n            stationsContainer.addChild(sprite);\r\n            let clickStarts = () => {\r\n              sprite.clickStartedDate = new Date().getTime();\r\n            }\r\n            let clickEnds = () => {\r\n              if(new Date().getTime() - sprite.clickStartedDate < 1000) ctx.emit(\"station-clicked\", i+1);\r\n            }\r\n            sprite.on(\"mousedown\", clickStarts);\r\n            sprite.on(\"touchstart\", clickStarts);\r\n            sprite.on(\"mouseup\", clickEnds);\r\n            sprite.on(\"touchend\", clickEnds);\r\n          }\r\n\r\n          app.stage.addChild(backgroundContainer);\r\n          app.stage.addChild(buildingsContainer);\r\n          app.stage.addChild(streetsContainer);\r\n          app.stage.addChild(pathsContainer);\r\n          app.stage.addChild(stationsContainer);\r\n\r\n          let pawnsContainer = new PIXI.Container();\r\n          props.players.forEach(player => {\r\n            let texture = textures.pawns[player.color+1];\r\n            let sprite = new PIXI.Sprite(texture);\r\n            if(player.position) {\r\n              let point = stations[player.position - 1].point;\r\n              sprite.x = point[0] * tileSize;\r\n              sprite.y = (point[1]-1) * tileSize;\r\n              sprite.interactive = true;\r\n              sprite.on(\"mouseover\", () => {\r\n                sprite.texture = textures.paths[70];\r\n              });\r\n              sprite.on(\"mouseout\", () => {\r\n                sprite.texture = texture;\r\n              });\r\n            } else {\r\n              sprite.visible = false;\r\n            }\r\n            pawnsContainer.addChild(sprite);\r\n          });\r\n\r\n          app.stage.addChild(pawnsContainer);\r\n\r\n          let updatePawns = (players) => {\r\n            players.forEach( (player, index) => {\r\n              let sprite = pawnsContainer.children[index];\r\n              if(player.position) {\r\n                sprite.visible = true;\r\n                let point = stations[player.position - 1].point;\r\n                sprite.x = point[0] * tileSize;\r\n                sprite.y = (point[1]-1) * tileSize;\r\n              } else {\r\n                sprite.visible = false;\r\n              }\r\n            });\r\n          };\r\n          window.mitt.on(\"update-pawns\", updatePawns);\r\n        });\r\n\r\n    app.loader.onError.add((e)=>{\r\n      console.error(e);\r\n    });\r\n\r\n    onMounted(() => {\r\n      document.getElementById(\"map-manager__main-panel\").appendChild(app.view);\r\n      const dragging = ref(false);\r\n      let width = window.innerWidth<501 ? window.innerWidth : window.innerHeight*1.5;\r\n      let defaultScale = width / 60 / 64;\r\n      const container = document.getElementById(\"map-manager__main-panel\");\r\n      let instance = renderer({\r\n        minScale: Math.min(zoomAndPanParams.minZoom, defaultScale),\r\n        maxScale: zoomAndPanParams.maxZoom,\r\n        element: container.children[0],\r\n        scaleSensitivity: zoomAndPanParams.zoomSensibility,\r\n        defaultScale: defaultScale,\r\n        containerDimension: {\r\n          width: container.clientWidth,\r\n          height: container.clientHeight\r\n        }\r\n      });\r\n\r\n      window.addEventListener(\"resize\", ()=>{\r\n        width = window.innerWidth<501 ? window.innerWidth : window.innerHeight*1.5;\r\n        defaultScale = width / 60 / 64;\r\n        instance = renderer({\r\n          minScale: Math.min(zoomAndPanParams.minZoom, defaultScale),\r\n          maxScale: zoomAndPanParams.maxZoom,\r\n          element: container.children[0],\r\n          scaleSensitivity: zoomAndPanParams.zoomSensibility,\r\n          defaultScale: defaultScale,\r\n          containerDimension: {\r\n            width: container.clientWidth,\r\n            height: container.clientHeight\r\n          }\r\n        });\r\n      })\r\n\r\n      const zoomToPawn = (player) => {\r\n        instance.toDefault();\r\n        if(!player.position) return;\r\n        let x = tileSize * stations[player.position-1].point[0] * defaultScale;\r\n        let y = tileSize * stations[player.position-1].point[1] * defaultScale;\r\n        instance.zoom({\r\n          x: x,\r\n          y: y,\r\n          deltaScale: zoomAndPanParams.defaultZoom\r\n        });\r\n      }\r\n      instance.toDefault();\r\n      if (props.autoZoom) zoomToPawn(props.currentPlayer);\r\n\r\n      window.mitt.on(\"zoom-to-default\", instance.toDefault);\r\n      window.mitt.on(\"zoom-to-pawn\", zoomToPawn);\r\n\r\n      container.addEventListener(\"wheel\", (event) => {\r\n        event.preventDefault();\r\n        instance.zoom({\r\n          deltaScale: Math.sign(event.deltaY),\r\n          x: event.pageX,\r\n          y: event.pageY\r\n        });\r\n      });\r\n\r\n      container.addEventListener(\"mousedown\", () => {\r\n        dragging.value = true;\r\n        document.body.style.cursor = \"move\";\r\n      });\r\n\r\n      container.addEventListener(\"dblclick\", (event) => {\r\n        event.preventDefault();\r\n        if(!instance.isToDefault()) instance.toDefault();\r\n        else instance.zoom({\r\n          x: event.pageX,\r\n          y: event.pageY,\r\n          deltaScale: zoomAndPanParams.defaultZoom\r\n        });\r\n      })\r\n\r\n      container.addEventListener(\"mousemove\", (event) => {\r\n        if (!dragging.value) return;\r\n        event.preventDefault();\r\n        instance.panBy({\r\n          originX: event.movementX,\r\n          originY: event.movementY\r\n        });\r\n      });\r\n\r\n      container.addEventListener(\"mouseup\", () => {\r\n        dragging.value = false;\r\n        document.body.style.cursor = \"default\";\r\n      });\r\n\r\n      let previousTouch;\r\n      let lastMiddlePoint;\r\n      let lastDistance;\r\n      const getDistanceFromTouches = (touches) => Math.sqrt( Math.pow(touches[0].pageX-touches[1].pageX, 2) + Math.pow(touches[0].pageY-touches[1].pageY, 2) )\r\n      const getMiddlePointFromTouches = (touches) => {\r\n        return {\r\n          x: (touches[0].pageX+touches[1].pageX)/2,\r\n          y: (touches[0].pageY+touches[1].pageY)/2\r\n        }\r\n      }\r\n      container.addEventListener(\"touchstart\", (event) => {\r\n        if(event.touches.length <= 2) {\r\n          previousTouch = event;\r\n          if (event.touches.length === 2) {\r\n            lastDistance = getDistanceFromTouches(event.touches);\r\n            lastMiddlePoint = getMiddlePointFromTouches(event.touches);\r\n          }\r\n        }\r\n      });\r\n\r\n      container.addEventListener(\"touchmove\", (event) => {\r\n        if(event.touches.length === 1){\r\n          let dx = event.touches[0].pageX-previousTouch.touches[0].pageX;\r\n          let dy = event.touches[0].pageY-previousTouch.touches[0].pageY;\r\n          instance.panBy({\r\n            originX: dx,\r\n            originY: dy\r\n          });\r\n          previousTouch = event;\r\n        }else if(event.touches.length === 2) {\r\n          let distance = getDistanceFromTouches(event.touches);\r\n          let deltaScale = Math.sign(distance/lastDistance - 1) / 2;\r\n\r\n          let {x, y} = getMiddlePointFromTouches(event.touches);\r\n          instance.zoom({x, y, deltaScale});\r\n          instance.panBy({\r\n            originX: x - lastMiddlePoint.x,\r\n            originY: y - lastMiddlePoint.y\r\n          });\r\n          lastMiddlePoint = {x, y};\r\n          lastDistance = distance;\r\n\r\n        }\r\n      });\r\n\r\n      let lastTimestamp;\r\n      let lastPositions;\r\n      container.addEventListener(\"touchend\", (event)=>{\r\n        if(lastTimestamp && lastPositions){\r\n          if(event.timeStamp-lastTimestamp<zoomAndPanParams.doubleTapTimeTolerance){\r\n            if(event.changedTouches.length===1){\r\n              if(Math.abs(event.changedTouches[0].pageX-lastPositions.pageX)<zoomAndPanParams.doubleTapDistanceTolerance){\r\n                if(Math.abs(event.changedTouches[0].pageY-lastPositions.pageY)<zoomAndPanParams.doubleTapDistanceTolerance){\r\n                  event.preventDefault();\r\n                  if(!instance.isToDefault()) instance.toDefault();\r\n                  else instance.zoom({\r\n                    x: event.changedTouches[0].pageX,\r\n                    y: event.changedTouches[0].pageY,\r\n                    deltaScale: zoomAndPanParams.defaultZoom\r\n                  });\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        lastTimestamp = event.timeStamp;\r\n        lastPositions = {pageX: event.changedTouches[0].pageX, pageY: event.changedTouches[0].pageY}\r\n      })\r\n\r\n      window.addEventListener(\"keydown\", (event) => keyPressed(event, instance));\r\n    });\r\n\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n\r\n.map-manager__main-panel{\r\n  overflow: hidden;\r\n  width: 100%;\r\n  height: 100%;\r\n  @media (max-width: 500px) {\r\n    width: 100%;\r\n    height: 300px;\r\n    position: sticky;\r\n    top: 0;\r\n    z-index: 2;\r\n  }\r\n}\r\n</style>\r\n"]}]}